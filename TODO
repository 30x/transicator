# Changes necessary for new data model:

New API for changeserver:
  Given {xmin, xmax, xip...}, return the commit sequence that matches.
  This will probably require another index in LDB.
  Greg can also work on this.

# Other changes

changeserver must persist last "commit sequence" that it received from
the database and committed to LevelDB. (The "metadata" functions in the
"storage" module can be used for this.) Changeserver must ignore anything
pushed from the database that is <= this sequence. This is important because
we do not send the LSN that was applied back to Postgres on a regular basis,
and even if we do it looks like sometimes PG sends us back old changes that
we already saw, especially after a restart.

changeserver must be able to handle a Postgres disconnect by reporting the
disconnect, and trying to reconnect using an exponential backoff.

changeserver must be able to start up even if Postgres is unavailable, start
reconnect attempts using an exponential backoff, and eventually connect
when PG is available.

Consider what happens for a big transaction -- Postgres will return us
many records, each with the same commit sequence, and different values
of "index." Should the "/changes" API always return them all, even if
"limit" is exceeded? It might simplify things.

# Lower Priority

SSL to Postgres server using PG's weird SSL techique. (Greg can do that.)

Add basic authentication to the API. (Greg has code for that.)

Complete the health check mechanism so that a load balancer can mark the server
down for a zero-downtime replacement. (Greg can do that.)

Docker image and repo for building it on Docker Hub.

Deployment to E2E Kubernetes.

Support the "Comet" technique or even WebSockets in addition to long polling.

Investigate binary support for the change log from PG to LevelDB.
